# Protocol Message Dataset

![Version](https://img.shields.io/badge/version-v1.0-blue)
![Python](https://img.shields.io/badge/python-3.8%2B-green)
![License](https://img.shields.io/badge/license-MIT-yellow)
![Status](https://img.shields.io/badge/status-production-brightgreen)

## 📋 Overview

This module is a comprehensive toolkit for generating protocol message datasets. It provides specialized generators for multiple network and industrial protocols, producing RFC-compliant and standard-conformant message datasets in both CSV and PCAP formats. These datasets are designed for protocol reverse engineering, network traffic analysis, and machine learning applications in network security.

**Note**: All protocol generators in this module were automatically generated by Large Language Models (LLMs) following strict adherence to official protocol specifications and RFC standards, ensuring high-quality, standards-compliant message generation.

**Public Datasets**: The `public/` folder contains  public datasets for industrial protocols (S7Comm, Modbus TCP, OMRON FINS). See [ Public Datasets](#-public-datasets) section for details.

### Key Features

- ✅ **RFC/Standard Compliance**: Strictly follows protocol specifications (RFC documents and vendor standards)
- ✅ **Dual Format Output**: Generates both CSV (for ML training) and PCAP (for validation) formats
- ✅ **Highly Configurable**: Supports diverse message generation patterns and parameters
- ✅ **External Tool Validation**: Verified with Wireshark/tshark for correctness
- ✅ **Production Ready**: Suitable for network security research, protocol testing, and traffic analysis

---

## 🚀 Protocol Generators

| Protocol             | Generator File              | RFC/Standard        | Status |
| -------------------- | --------------------------- | ------------------- | ------ |
| **TCP**        | `tcp_generator.py`        | RFC 793/9293        | ✅     |
| **UDP**        | `udp_generator.py`        | RFC 768             | ✅     |
| **ARP**        | `arp_generator.py`        | RFC 826             | ✅     |
| **DNS**        | `dns_generator.py`        | RFC 1035            | ✅     |
| **MQTT**       | `mqtt_generator.py`       | MQTT v3.1.1         | ✅     |
| **CoAP**       | `coap_generator.py`       | RFC 7252            | ✅     |
| **BGP**        | `bgp_generator.py`        | RFC 4271            | ✅     |
| **RADIUS**     | `radius_generator.py`     | RFC 2865            | ✅     |
| **Modbus**     | `modbus_generator.py`     | Modbus v1.1b3       | ✅     |
| **S7Comm**     | `s7comm_generator.py`     | Siemens S7 Protocol | ✅     |
| **OMRON FINS** | `omron_fins_generator.py` | FINS Protocol Spec  | ✅     |
| **HART-IP**    | `hart_ip_generator.py`    | HART-IP Spec        | ✅     |

> **Note**: In our paper, we use `tcp`, `udp`, `arp`, `dns`, `bgp`, and `radius` as training data, with the remaining protocols serving as test protocols for cross-protocol generalization evaluation.

---

## 📂 Directory Structure

```
generate/
├── 📄 README.md                    # Project documentation
│
├── 🐍 Protocol Generators          # Individual generator scripts
│   ├── tcp_generator.py           # TCP protocol generator
│   ├── udp_generator.py           # UDP protocol generator
│   ├── arp_generator.py           # ARP protocol generator
│   ├── dns_generator.py           # DNS protocol generator
│   ├── icmp_generator.py          # ICMP protocol generator
│   ├── modbus_generator.py        # Modbus protocol generator
│   ├── mqtt_generator.py          # MQTT protocol generator
│   ├── coap_generator.py          # CoAP protocol generator
│   ├── s7comm_generator.py        # S7Comm protocol generator
│   ├── omron_fins_generator.py    # OMRON FINS protocol generator
│   ├── hart_ip_generator.py       # HART-IP protocol generator
│   ├── bgp_generator.py           # BGP protocol generator
│   └── radius_generator.py        # RADIUS protocol generator
│
├── 📁 csv/                         # CSV format output directory
│   ├── tcp_messages.csv           # TCP message dataset
│   ├── modbus_messages.csv        # Modbus message dataset
│   ├── mqtt_messages.csv          # MQTT message dataset
│   ├── s7comm_messages.csv        # S7Comm message dataset
│   └── ...                        # Other protocol datasets
│
├── 📁 pcap/                        # PCAP format output directory
│   ├── tcp_messages.pcap          # TCP packet captures
│   ├── modbus_messages.pcap       # Modbus packet captures
│   └── ...                        # Other protocol captures
│
├── 📁 public/                      # Public datasets
│   ├── s7comm.pcap                # S7Comm public PCAP
│   ├── s7comm_public_messages.csv # S7Comm public CSV dataset
│   ├── ModbusTCP_1000.pcap        # Modbus public PCAP
│   ├── modbus_public_messages.csv # Modbus public CSV dataset
│   ├── omron_1000.pcap            # OMRON FINS public PCAP
│   └── omron_public_messages.csv  # OMRON FINS public CSV dataset
│
├── 🔧 Utility Scripts
│   ├── pcap_to_csv.py             # Convert PCAP to CSV format
│   └── filter_messages.py         # Filter and clean message datasets
```

---

## 📊 Output Data Structure

### CSV Format Specification

All generated CSV files follow a standardized three-column format:

```csv
Hex,Segment,Field Names
```

#### Column Descriptions

**1. Hex Column**

- **Content**: Complete message payload in hexadecimal representation
- **Format**: Continuous hex string (e.g., `0006000000060100030000000a`)
- **Purpose**: Raw byte sequence for ML model input

**Example:**

```
0006000000060100030000000a
```

**2. Segment Column**

- **Content**: List of field boundary coordinates (start, end) in Python list format
- **Format**: `[(start1, end1), (start2, end2), ...]`
- **Unit**: Byte offsets (0-based indexing)
- **Purpose**: Ground truth labels for boundary prediction

**Example:**

```
[(0, 2), (2, 4), (4, 6), (6, 7), (7, 8), (8, 10), (10, 12)]
```

This indicates:

- Bytes 0-2: First field
- Bytes 2-4: Second field
- Bytes 4-6: Third field
- ... and so on

**3. Field Names Column**

- **Content**: List of semantic field names corresponding to segments
- **Format**: Python list of strings `['Field1', 'Field2', ...]`
- **Purpose**: Field semantics for interpretability and analysis

**Example:**

```
['Transaction ID', 'Protocol ID', 'Length', 'Unit ID', 'Function Code', 'Start Address', 'Quantity']
```

#### Complete CSV Row Example (Modbus)

```csv
Hex,Segment,Field Names
0006000000060100030000000a,"[(0, 2), (2, 4), (4, 6), (6, 7), (7, 8), (8, 10), (10, 12)]","['Transaction ID', 'Protocol ID', 'Length', 'Unit ID', 'Function Code', 'Start Address', 'Quantity']"
```

**Breakdown:**

- **Hex**: `0006000000060100030000000a` (12 bytes = 24 hex digits)
- **Segments**: 7 fields with boundaries at bytes: [0-2], [2-4], [4-6], [6-7], [7-8], [8-10], [10-12]
- **Field Names**: Modbus TCP header fields + function code + parameters

### PCAP Format Specification

PCAP files contain standard Wireshark-compatible packet captures:

- **Format**: Standard libpcap format
- **Layers**: Complete protocol stack (Ethernet → IP → TCP/UDP → Application)
- **Validation**: Fully parseable by Wireshark, tshark, and tcpdump
- **Purpose**: Verify correctness of generated messages using external tools

---

## 🔧 Usage Guide

### Prerequisites

**Required:**

- Python 3.8 or higher
- Scapy library: `pip install scapy`

**Optional (for specific protocols):**

- crcmod: `pip install crcmod` (for CRC calculations in industrial protocols)

### Basic Usage

**Generate a single protocol dataset:**

```bash
# Navigate to the generate directory
cd opensource_release/generate

# Run a specific generator
python modbus_generator.py
```

**Output:**

- CSV file: `csv/modbus_messages.csv`
- PCAP file: `pcap/modbus_messages.pcap`

### Batch Generation

Generate datasets for all protocols:

```bash
# Linux/macOS
for file in *_generator.py; do python "$file"; done

# Windows PowerShell
Get-ChildItem -Filter "*_generator.py" | ForEach-Object { python $_.Name }
```

### Customization

Modify the number of generated messages by editing the generator script:

```python
# Example: modbus_generator.py
if __name__ == "__main__":
    generator = ModbusGenerator()
    packets = generator.generate_packets(500)  # Change from default (e.g., 200) to 500
    # ... rest of code
```

### PCAP to CSV Conversion

Convert custom PCAP files to CSV format:

```bash
python pcap_to_csv.py --pcap custom_traffic.pcap --protocol modbus --output csv/custom_modbus.csv
```

---

## 📦 Public Datasets

The `public/` directory contains publicly available datasets for research and benchmarking:

### Available Public Datasets

| Protocol             | PCAP File               | CSV File                       | Packet Count | Description                            |
| -------------------- | ----------------------- | ------------------------------ | ------------ | -------------------------------------- |
| **S7Comm**     | `s7comm.pcap`         | `s7comm_public_messages.csv` | ~1000        | Siemens S7 communication messages      |
| **Modbus**     | `ModbusTCP_1000.pcap` | `modbus_public_messages.csv` | ~1000        | Modbus TCP industrial control messages |
| **OMRON FINS** | `omron_1000.pcap`     | `omron_public_messages.csv`  | ~1000        | OMRON FINS protocol messages           |

### Public Dataset Characteristics

- **Source**: The public datasets are sourced from the following open-source repositories:

  - [Industrial Protocols Dataset](https://github.com/hi-zer/Industrial-protocols-dataset)
  - [ICS Security Tools](https://github.com/ITI/ICS-Security-Tools)

  We thank the authors of these repositories for providing valuable industrial protocol datasets for research purposes.

---

## 🛠️ Utility Scripts

### pcap_to_csv.py

Converts PCAP packet captures to CSV format for ML training.

**Functionality:**

- Uses tshark to parse PCAP files with protocol dissection
- Extracts field boundaries and names from tshark JSON output
- Generates CSV files compatible with training scripts

**Basic Usage:**

```bash
python pcap_to_csv.py --pcap pcap/modbus_messages.pcap --protocol modbus --output csv/output.csv
```

### filter_messages.py

Filters and cleans message datasets based on various criteria.

**Functionality:**

- Remove duplicate messages
- Filter by message length
- Filter by specific field values
- Clean malformed entries (if any)

**Basic Usage:**

```bash
python filter_messages.py --input csv/modbus_messages.csv --output csv/modbus_filtered.csv --min-length 10
```

---

## 🔬 Research Applications

### Protocol Reverse Engineering

The datasets are specifically designed for training models to detect protocol field boundaries:

- **Input**: Raw hex byte sequences
- **Labels**: Field boundary coordinates (segments)
- **Semantics**: Field names for interpretation

### Network Traffic Analysis

- Traffic pattern recognition
- Protocol fingerprinting
- Anomaly detection in industrial networks

### Industrial Control System (ICS) Security

- SCADA protocol analysis
- ICS intrusion detection
- Protocol fuzzing and testing

---

## 📄 License

This project is licensed under the MIT License.

---

## 🆘 Support and Contact

For questions, issues, or contributions:

1. Check the [main project README](../README.md)
2. Open an issue in the project repository

---
